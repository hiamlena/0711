<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Яндекс.Карты — ObjectManager пример</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      body {
        font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
        position: relative;
      }

      #map {
        width: 100%;
        height: 100vh;
        position: relative;
        z-index: 1;
      }

      #ui.panel {
        position: absolute;
        top: 16px;
        right: 16px;
        width: min(320px, calc(100% - 32px));
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.96);
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
        z-index: 1000;
        box-sizing: border-box;
      }

      #ui .row {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      #ui .row label {
        font-size: 13px;
        color: #1f2937;
      }

      #ui input[type='text'],
      #ui input[type='search'],
      #ui input[type='url'],
      #ui input[type='number'],
      #ui input[type='tel'],
      #ui input[type='email'],
      #ui input[type='password'],
      #ui input,
      #ui button {
        font: inherit;
      }

      #ui input {
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        box-sizing: border-box;
        width: 100%;
      }

      #ui input:focus {
        outline: 2px solid #2563eb;
        outline-offset: 1px;
        border-color: #2563eb;
      }

      #ui .row.gap {
        flex-direction: row;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
      }

      #ui .row.gap button {
        flex: 1 1 33%;
      }

      #ui .via-row {
        flex-direction: row;
        align-items: center;
        gap: 8px;
      }

      #ui button {
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid #2563eb;
        background-color: #2563eb;
        color: #fff;
        cursor: pointer;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
      }

      #ui button:hover {
        background-color: #1d4ed8;
        box-shadow: 0 6px 18px rgba(37, 99, 235, 0.25);
      }

      #ui button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
      }

      #ui .via-row button {
        flex: 0 0 auto;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #ef4444;
        background-color: #ef4444;
      }

      #ui .via-row button:hover {
        background-color: #dc2626;
      }

      #ui .checkbox-row {
        flex-direction: row;
        align-items: center;
        gap: 8px;
      }

      #ui .checkbox-row label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 14px;
      }
    </style>
    <!--
      Пример структуры файла data/frames.geojson:
      {
        "type": "FeatureCollection",
        "features": [
          {
            "type": "Feature",
            "id": "moscow-frame",
            "geometry": {
              "type": "Point",
              "coordinates": [37.617635, 55.755814]
            },
            "properties": {
              "id": "moscow-frame",
              "name": "Москва",
              "status": "Готово",
              "url": "https://example.com/moscow"
            }
          },
          {
            "type": "Feature",
            "id": "spb-frame",
            "geometry": {
              "type": "Point",
              "coordinates": [30.315868, 59.939095]
            },
            "properties": {
              "id": "spb-frame",
              "name": "Санкт-Петербург",
              "status": "В процессе",
              "url": "https://example.com/spb"
            }
          },
          {
            "type": "Feature",
            "id": "novosibirsk-frame",
            "geometry": {
              "type": "Point",
              "coordinates": [82.9346, 55.0415]
            },
            "properties": {
              "id": "novosibirsk-frame",
              "name": "Новосибирск",
              "status": "Запланировано",
              "url": "https://example.com/novosibirsk"
            }
          }
        ]
      }
    -->
  </head>
  <body>
    <div id="map"></div>
    <div id="ui" class="panel">
      <div class="row">
        <label for="from">Откуда</label>
        <input id="from" placeholder="Адрес или точка" type="text" />
      </div>
      <div class="row">
        <label for="to">Куда</label>
        <input id="to" placeholder="Адрес или точка" type="text" />
      </div>
      <div id="vias" class="row" aria-live="polite"></div>
      <div class="row gap">
        <button id="addVia" type="button">+ via</button>
        <button id="build" type="button">Построить</button>
        <button id="clear" type="button">Очистить</button>
      </div>
      <div class="row checkbox-row">
        <label>
          <input type="checkbox" id="toggleFrames" checked />
          Показать рамки
        </label>
      </div>
      <div class="row">
        <button id="openNav" type="button">Открыть в Навигаторе</button>
      </div>
    </div>

    <script>
      const GEOJSON_URL = './data/frames.geojson';
      let mapInstance = null;
      let objectManager = null;
      let featureIdCounter = 1;
      let multiRoute = null;
      let framesData = null;
      let framesVisible = true;
      let framesLayerAdded = false;
      let routeUpdateTimer = null;

      console.log('Yandex Maps: init start');

      function scheduleRouteBuild() {
        if (routeUpdateTimer) {
          clearTimeout(routeUpdateTimer);
        }
        routeUpdateTimer = window.setTimeout(() => {
          routeUpdateTimer = null;
          buildRoute();
        }, 400);
      }

      function createSuggest(inputId) {
        const suggestView = new ymaps.SuggestView(inputId);
        suggestView.events.add('select', () => {
          scheduleRouteBuild();
        });

        const input = document.getElementById(inputId);
        if (input) {
          const handleRouteChange = () => scheduleRouteBuild();
          input.addEventListener('input', handleRouteChange);
          input.addEventListener('change', handleRouteChange);
          input.addEventListener('blur', handleRouteChange);
          input.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              buildRoute();
            }
          });
        }

        return suggestView;
      }

      function getReferencePoints() {
        const from = document.getElementById('from')?.value.trim();
        const to = document.getElementById('to')?.value.trim();
        const vias = Array.from(document.querySelectorAll('.via')).map((input) =>
          input.value.trim(),
        );

        const references = [];
        if (from) {
          references.push(from);
        }
        references.push(...vias.filter(Boolean));
        if (to) {
          references.push(to);
        }

        return references;
      }

      function ensureMultiRoute() {
        if (multiRoute || !mapInstance) {
          return;
        }

        multiRoute = new ymaps.multiRouter.MultiRoute(
          { referencePoints: [] },
          {
            boundsAutoApply: true,
            routeActiveStrokeWidth: 6,
            routeStrokeStyle: 'solid',
          },
        );

        mapInstance.geoObjects.add(multiRoute);
      }

      function buildRoute() {
        ensureMultiRoute();
        if (!multiRoute) {
          return;
        }

        const references = getReferencePoints();
        if (references.length >= 2) {
          multiRoute.model.setReferencePoints(references);
        } else {
          multiRoute.model.setReferencePoints([]);
        }
      }

      function addViaInput() {
        const container = document.getElementById('vias');
        if (!container) {
          return;
        }

        const id = `via-${Date.now()}`;
        const wrapper = document.createElement('div');
        wrapper.className = 'row via-row';
        wrapper.innerHTML = `
          <input id="${id}" class="via" placeholder="Через…" type="text" />
          <button type="button" data-remove="${id}" aria-label="Удалить точку">×</button>
        `;

        container.appendChild(wrapper);
        createSuggest(id);

        const removeButton = wrapper.querySelector('button');
        if (removeButton) {
          removeButton.addEventListener('click', () => {
            wrapper.remove();
            scheduleRouteBuild();
          });
        }
      }

      function clearAll() {
        const fromInput = document.getElementById('from');
        const toInput = document.getElementById('to');
        const viasContainer = document.getElementById('vias');

        if (fromInput) {
          fromInput.value = '';
        }
        if (toInput) {
          toInput.value = '';
        }
        if (viasContainer) {
          viasContainer.innerHTML = '';
        }

        if (multiRoute) {
          multiRoute.model.setReferencePoints([]);
        }

        if (fromInput) {
          fromInput.focus();
        }
      }

      function toggleFramesLayer(on) {
        framesVisible = Boolean(on);

        if (!mapInstance || !objectManager) {
          return;
        }

        if (framesVisible) {
          if (!framesLayerAdded) {
            mapInstance.geoObjects.add(objectManager);
            framesLayerAdded = true;
          }
          objectManager.removeAll();
          if (framesData) {
            objectManager.add(framesData);
          }
        } else {
          objectManager.removeAll();
          if (framesLayerAdded) {
            mapInstance.geoObjects.remove(objectManager);
            framesLayerAdded = false;
          }
        }
      }

      function buildNavigatorLink() {
        const references = getReferencePoints();
        if (references.length < 2) {
          return '#';
        }

        return `https://yandex.ru/maps/?mode=routes&rtext=${encodeURIComponent(
          references.join('~'),
        )}`;
      }

      function wireUI() {
        createSuggest('from');
        createSuggest('to');

        const toggleFramesCheckbox = document.getElementById('toggleFrames');
        if (toggleFramesCheckbox) {
          framesVisible = toggleFramesCheckbox.checked;
          toggleFramesCheckbox.addEventListener('change', (event) => {
            toggleFramesLayer(event.target.checked);
          });
        }

        const addViaButton = document.getElementById('addVia');
        if (addViaButton) {
          addViaButton.addEventListener('click', () => {
            addViaInput();
            scheduleRouteBuild();
          });
        }

        const buildButton = document.getElementById('build');
        if (buildButton) {
          buildButton.addEventListener('click', () => buildRoute());
        }

        const clearButton = document.getElementById('clear');
        if (clearButton) {
          clearButton.addEventListener('click', () => {
            clearAll();
            buildRoute();
          });
        }

        const openNavButton = document.getElementById('openNav');
        if (openNavButton) {
          openNavButton.addEventListener('click', () => {
            const href = buildNavigatorLink();
            if (href === '#') {
              console.warn('Navigator: недостаточно точек для построения маршрута');
              return;
            }
            window.open(href, '_blank', 'noopener');
          });
        }
      }

      function createBalloonContent(properties = {}) {
        const status = typeof properties.status === 'string' && properties.status.trim() !== ''
          ? properties.status
          : 'Статус не указан';
        const url = typeof properties.url === 'string' && properties.url.trim() !== ''
          ? `<a href="${properties.url}" target="_blank" rel="noopener noreferrer">Открыть</a>`
          : 'Ссылка отсутствует';
        const title = typeof properties.name === 'string' && properties.name.trim() !== ''
          ? `<strong>${properties.name}</strong>`
          : '';
        return `
          <div class="balloon">
            ${title}
            <div>Статус: ${status}</div>
            <div>${url}</div>
          </div>
        `;
      }

      async function loadGeoJsonCollection() {
        console.log('GeoJSON: старт загрузки', GEOJSON_URL);
        const response = await fetch(GEOJSON_URL, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`GeoJSON: ошибка загрузки ${response.status} ${response.statusText}`);
        }

        const fc = await response.json();
        if (!fc || fc.type !== 'FeatureCollection') {
          throw new Error('GeoJSON: ожидался FeatureCollection');
        }
        if (!Array.isArray(fc.features)) {
          throw new Error('GeoJSON: отсутствует массив features');
        }
        if (fc.features.length === 0) {
          throw new Error('GeoJSON: массив features пуст');
        }

        const firstFeature = fc.features[0];
        if (!firstFeature || !firstFeature.geometry || firstFeature.geometry.type !== 'Point') {
          throw new Error('GeoJSON: первая фича должна быть Point');
        }
        const firstCoords = firstFeature.geometry.coordinates;
        if (!Array.isArray(firstCoords) || firstCoords.length < 2) {
          throw new Error('GeoJSON: первые координаты заданы неверно');
        }

        console.log(`GeoJSON: загружено ${fc.features.length} фич (включая потенциально невалидные)`);
        console.log('GeoJSON: первые координаты', firstCoords[0], firstCoords[1]);

        return fc;
      }

      function prepareFeatureCollection(rawCollection) {
        const validFeatures = [];
        const invalidSamples = [];
        let validCount = 0;
        let invalidCount = 0;

        for (let index = 0; index < rawCollection.features.length; index += 1) {
          const feature = rawCollection.features[index];
          const geometry = feature && feature.geometry;
          const coords = geometry && geometry.coordinates;

          if (!feature || geometry?.type !== 'Point') {
            invalidCount += 1;
            if (invalidSamples.length < 3) {
              invalidSamples.push({ index, reason: 'Geometry is not Point', geometry });
            }
            continue;
          }

          if (!Array.isArray(coords) || coords.length < 2) {
            invalidCount += 1;
            if (invalidSamples.length < 3) {
              invalidSamples.push({ index, reason: 'Coordinates are not an array[lon, lat]', coordinates: coords });
            }
            continue;
          }

          const lon = Number(coords[0]);
          const lat = Number(coords[1]);
          if (!Number.isFinite(lon) || !Number.isFinite(lat)) {
            invalidCount += 1;
            if (invalidSamples.length < 3) {
              invalidSamples.push({ index, reason: 'Coordinates are not finite numbers', coordinates: coords });
            }
            continue;
          }

          const properties = Object.assign({}, feature.properties || {});
          const featureId = feature.id || properties.id || `feature-${featureIdCounter++}`;
          const preparedFeature = {
            type: 'Feature',
            id: featureId,
            geometry: {
              type: 'Point',
              coordinates: [lon, lat],
            },
            properties: Object.assign(properties, {
              balloonContent: createBalloonContent(properties),
              hintContent:
                properties.hint ||
                properties.name ||
                properties.status ||
                String(featureId),
            }),
            options: {
              preset: 'islands#redCircleDotIcon',
              zIndex: 650,
              zIndexActive: 700,
            },
          };

          validFeatures.push(preparedFeature);
          validCount += 1;
        }

        console.log(`GeoJSON: всего ${rawCollection.features.length}, валидных ${validCount}, невалидных ${invalidCount}`);
        if (invalidSamples.length > 0) {
          console.warn('GeoJSON: примеры невалидных фич', invalidSamples);
        }

        if (validCount === 0) {
          console.warn('GeoJSON: валидных точек не найдено, ObjectManager обновляться не будет');
          return null;
        }

        return {
          type: 'FeatureCollection',
          features: validFeatures,
        };
      }

      async function loadAndRenderData() {
        try {
          const rawCollection = await loadGeoJsonCollection();
          const preparedCollection = prepareFeatureCollection(rawCollection);
          if (!preparedCollection) {
            return;
          }

          framesData = preparedCollection;
          toggleFramesLayer(framesVisible);
          console.log(
            `ObjectManager: подготовлено ${preparedCollection.features.length} точек (слой ${
              framesVisible ? 'включен' : 'выключен'
            })`,
          );

          const boundsCoords = preparedCollection.features
            .map((feature) => feature?.geometry?.coordinates)
            .filter((coords) => Array.isArray(coords) && coords.length >= 2);
          if (boundsCoords.length > 0) {
            const bounds = ymaps.util.bounds.fromPoints(boundsCoords);
            if (bounds) {
              console.log('Yandex Maps: применяем границы по данным');
              mapInstance.setBounds(bounds, { checkZoomRange: true, zoomMargin: 40 });
            }
          }
        } catch (error) {
          console.error('GeoJSON: ошибка отображения данных', error);
        }
      }

      async function initMap() {
        try {
          console.log('Yandex Maps: создание экземпляра карты');
          mapInstance = new ymaps.Map(
            'map',
            {
              center: [55.751244, 37.618423],
              zoom: 5,
              controls: ['zoomControl', 'typeSelector', 'geolocationControl'],
            },
            {
              suppressMapOpenBlock: true,
            },
          );
          console.log('Yandex Maps: карта инициализирована успешно');

          objectManager = new ymaps.ObjectManager({
            clusterize: true,
            gridSize: 64,
            clusterDisableClickZoom: false,
            geoObjectHideIconOnBalloonOpen: false,
          });

          objectManager.objects.options.set('preset', 'islands#redCircleDotIcon');
          objectManager.objects.options.set('zIndex', 650);
          objectManager.objects.options.set('zIndexActive', 700);
          objectManager.objects.options.set('openBalloonOnClick', true);

          objectManager.clusters.options.set('zIndex', 650);
          objectManager.clusters.options.set('zIndexActive', 700);
          objectManager.clusters.events.add('click', (event) => {
            const target = event.get('target');
            if (target && typeof target.getBounds === 'function') {
              const clusterBounds = target.getBounds();
              if (clusterBounds) {
                console.log('ObjectManager: зум по кластеру');
                mapInstance.setBounds(clusterBounds, { checkZoomRange: true, zoomMargin: 40 });
              }
            }
          });

          ensureMultiRoute();
          wireUI();
          toggleFramesLayer(framesVisible);
          console.log('ObjectManager: слой рамок подготовлен, начинаем загрузку данных');
          await loadAndRenderData();
        } catch (error) {
          console.error('Yandex Maps: ошибка инициализации карты', error);
        }
      }

      window.handleYmapsLoaded = function handleYmapsLoaded() {
        console.log('Yandex Maps: API script loaded');
        if (window.ymaps && typeof ymaps.ready === 'function') {
          try {
            ymaps.ready(() => {
              console.log('Yandex Maps: ymaps.ready resolved');
              initMap();
            });
          } catch (error) {
            console.error('Yandex Maps: ymaps.ready вызвал ошибку', error);
          }
        } else {
          console.error('Yandex Maps: объект ymaps недоступен после загрузки скрипта');
        }
      };
    </script>

    <script
      src="https://api-maps.yandex.ru/2.1/?apikey=YOUR_YMAPS_API_KEY&lang=ru_RU"
      type="text/javascript"
      onload="window.handleYmapsLoaded()"
      onerror="console.error('Yandex Maps: не удалось загрузить API скрипт')"
    ></script>
  </body>
</html>
